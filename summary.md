<h1>ΣΥΣΤΗΜΑΤΑ ΔΙΑΧΕΙΡΙΣΗΣ ΒΑΣΕΩΝ ΔΕΔΟΜΕΝΩΝ | 2022-23</h1>

<h2>Ομάδα: Παναγιώτα Νικολάου Π20009, Κωνσταντίνος Λοϊζίδης Π20007, Δημήτρης Στυλιανού Π20004</h2>

<h3>Από τα ζητούμενα της εργασίας, υλοποιήθηκαν όλα τα ερωτήματα (issue_1, issue_2 και issue_3). Έχουμε προσθέσει τα κατάλληλα σχόλια και docstrings για την επεξήγηση του κώδικα μας, για αυτό όσο είναι εφικτό θα γίνεται συντομοτέρη περιγραφή των βασικών αλλαγών/προσθηκών μας.</h3>

<h3>Αρχείο mdb.py</h3>

<h4>Συνάρτηση create_query_plan:</h4>
<i>

- Στο 'action==select' (γραμμή 79) προσθέσαμε την κλήση της συνάρτησης 'evaluate_where_clause',  η οποία υπολογίζει το 'where' clause το οποίο δεν ήταν υλοποιημένο. Η συγκεκριμένη συνάρτηση θα επεξηγηθεί παρακάτω.

<b>Παράδειγμα εκτέλεσης:</b><br>
Εγγραφές πίνακα:<br>
<img width="716" alt="image" src="https://user-images.githubusercontent.com/75742419/220193767-1071d12c-c798-4fed-838b-e8625b7678a2.png"><br>
Πλάνο εκτέλεσης:<br>
<img width="871" alt="image" src="https://user-images.githubusercontent.com/75742419/220194225-d8a74d94-4beb-4e26-b9fb-5e066cc46c19.png"><br>
Εκτέλεση ερωτήματος:<br>
<img width="844" alt="image" src="https://user-images.githubusercontent.com/75742419/220194410-5113b2e3-ff04-4e22-a054-794b520d366e.png"><br><br>

- Στο 'action==create table' (γραμμή 100) προσθέσαμε στην υπάρχων υλοποίηση την υποστήριξη ένα πεδίο να είναι 'unique'.

<b>Παράδειγμα εκτέλεσης:</b><br>
Πλάνο εκτέλεσης:<br>
<img width="924" alt="image" src="https://user-images.githubusercontent.com/75742419/220195070-bf4bd183-15f5-4a0e-9ee5-35a0750018dd.png"><br>
Εκτέλεση ερωτήματος:<br>
<img width="854" alt="image" src="https://user-images.githubusercontent.com/75742419/220191242-16a71822-abae-461b-b891-5dd157326f14.png"><br><br>

- Προσθέσαμε το 'action==delete from' (γραμμή 138) ώστε να υποστηρίζεται και η διαγραφή εγγραφής/ών. Όπως και στο select, καλούμε την συνάρτηση 'evaluate_where_clause'.

<b>Παράδειγμα εκτέλεσης:</b><br>
Εγγραφές πίνακα:<br>
<img width="716" alt="image" src="https://user-images.githubusercontent.com/75742419/220193767-1071d12c-c798-4fed-838b-e8625b7678a2.png"><br>
Πλάνο εκτέλεσης:<br>
<img width="805" alt="image" src="https://user-images.githubusercontent.com/75742419/220194943-1def5797-6591-4284-9e9b-9ed6533bc2da.png"><br>
Εκτέλεση ερωτήματος:<br>
<img width="714" alt="image" src="https://user-images.githubusercontent.com/75742419/220195207-831b79b6-d09c-49cd-b2a0-8bb8f65cea49.png"><br><br>

- Προσθέσαμε το 'action==update' (γραμμή 144) ώστε να υποστηρίζεται η ενημέρωση εγγραφής/ων. Επίσης, καλείται η συνάρτηση 'evaluate_where_clause'.

<b>Παράδειγμα εκτέλεσης:</b><br>
Εγγραφές πίνακα:<br>
<img width="713" alt="image" src="https://user-images.githubusercontent.com/75742419/220195800-f38de8ca-8cc1-426a-b3c0-16225a91b8c7.png"><br>
Πλάνο εκτέλεσης:<br>
<img width="653" alt="image" src="https://user-images.githubusercontent.com/75742419/220196078-e303b34a-6aa1-46f4-9fb0-998dbc19ac6e.png"><br>
Εκτέλεση ερωτήματος:<br>
<img width="709" alt="image" src="https://user-images.githubusercontent.com/75742419/220196046-b2c12494-ea59-4d30-baa8-c972fcb30c57.png"><br><br>

- Τροποποιήσαμε το 'action==create index' (γραμμή 150) ώστε να υπάρχει η δυνατότητα επιλογής του πεδίου που θέλουμε να υποστηρίζεται από ευρετήριο (btree ή hash).

<b>Παράδειγμα εκτέλεσης:</b><br>
Πλάνο εκτέλεσης:<br>
<img width="607" alt="image" src="https://user-images.githubusercontent.com/75742419/220196860-b705c425-2ed6-44b8-aa23-f69662c2af07.png"><br>
Εκτέλεση ερωτήματος:<br>
<img width="788" alt="image" src="https://user-images.githubusercontent.com/75742419/220196810-5c0b038f-2a9a-4718-bacd-bec3b2a4721c.png"><br>
</i>
<h4>Συνάρτηση evaluate_from_clause:</h4>
<i>
Στις γραμμές 185-189 επεκτείναμε το 'on' clause διότι το χρειαστήκαμε για να φτιάξουμε τα ισοδύναμα πλάνα εκτέλεσης (issue_3a).
</i><br>
<h4>Συνάρτηση evaluate_where_clause:</h4>
<i>
Την χρησιμοποιούν όλα τα queries που υποστηρίζουν το 'where' clause (select, delete και update).  Μέσα σε αυτή, δημιουργήσαμε 3 ιδιωτικές βοηθητικές συναρτήσεις:

1. convert_list_to_dict: Μετατρέπει μια λίστα με λεξικά σε ένα λεξικό, το οποίο μπορεί να περιέχει εμφωλευμένα λεξικά ανάλογα πόσο σύνθετο είναι το query μας.
2. build_list: Φτιάχνει μια λίστα από λεξικά, όπου κάθε λεξικό περιέχει την αριστερή και δεξιά συνθήκη ενός operator ('and' / 'or').
3. put_paren_in_oprt_and: Βοηθάει στη σωστή δημιουργία του πλάνου εκτέλεσης. Όταν υπάρχει 'and' operator που δεν είναι σε παρενθέσεις και ακολουθείται ή προηγείται από έναν 'or' operator, βάζουμε τις κατάλληλες παρενθέσεις ώστε να εξασφαλίσουμε την προτεραιότητα μεταξύ των operators 'and' και 'or'. <br>
Γενικά, η συνάρτηση evaluate_where_clause χρησιμοποιείται για την δημιουργία ενός σωστόυ πλάνου εκτέλεσης, υποστηρίζοντας σύνθετα 'where' clause για όλους τους operators (and, or, not και between).
</i><br>
<h4>Κύρια συνάρτηση (main):</h4><br>
<i>
Στην περίπτωση που δίνεται ένα κανονικό query χωρίς 'explain', οι γραμμές 482-485 υπολογίζουν τα διάφορα ισοδύναμα queries (εφόσον το δοθέν query υποστηρίζεται - από την υλοποίηση μας -) και επιστρέφουν αυτό με το μικρότερο κόστος (issue_3). Πιο συγκεκριμένα, η συνάρτηση 'multiple_query_plans' επιστρέφει μια λίστα με τα ισοδύναμα πλάνα εκτέλεσης ('queries') και μια λογική τιμή ('is_valid') και αν είναι True καλείται η συνάρτηση 'evaluate_query_plans' , η οποία επιστρέφει το query με το μικρότερο κόστος (εάν αυτό υποστηρίζεται).<br><br>
Ισοδύναμα πλάνα εκτέλεσης:<br><br>
<img width="893" alt="image" src="https://user-images.githubusercontent.com/75742419/220204157-ff9af5d9-35e8-478e-bda3-b5285bacdcec.png"><br><br>
Πλάνο εκτέλεσης με το ελάχιστο κόστος:<br><br>
<img width="894" alt="image" src="https://user-images.githubusercontent.com/75742419/220204275-206787a3-387d-4f83-8f39-0ba4e86a5a7a.png"><br>
</i><br>
<h3>Αρχείο database.py</h3>
<h4>Συνάρτηση __init__:</h4>
<i>
Προσθέσαμε το λεξικό stats όπου θα περιέχει τα στατιστίκα του κάθε πίνακα, στην γραμμή 38-39 τα φορτώνουμε μέσω της συνάρτησης 'load_statistics' και έπειτα τα υπολογίζουμε μέσω της συνάρτησης 'calculate_tables_statistics'. <br>
Στην γραμμή 53 δημιουργείται ο φάκελος όπου θα περιέχει το αρχείο (pkl) που αποθηκεύονται τα στατιστικά. <br>
Επίσης, στην γραμμή 61 προσθέσαμε τις στήλες 'indexed_column' και 'index_type' όπου μας είναι απαραίτητες για την αποθήκευση του ονόματος στήλης όπου δημιουργείται το ευρετήριο και τον τύπο του ευρετηρίου (btree, hash).
</i><br><br>
<h4>Συνάρτηση create_table:</h4>
<i>
Στις γραμμές 121-127 στέλνουμε σαν όρισμα στον constructor του Table τα 'unique' πεδία (οι αλλαγές στην κλάση Table θα αναφερθούν παρακάτω). Επίσης, στην γραμμή 133 υπολογίζουμε τα σταστικά του κάθε πίνακα ώστε να έχουμε στην διάθεση μας και τα στατιστικά του νέου πίνακα.
</i><br><br>
<h4>Συνάρτηση drop_table:</h4>
<i>
Στην γραμμή 152 υπολογίζουμε τα στατιστίκα του κάθε πίνακα ώστε να αφαιρεθούν τα στατιστικά του πίνακα που διαγράφηκε και στην γραμμή 166 κάναμε την απαραίτητη αλλαγή ώστε να παίρνουμε τη σωστή στήλη (index_name).
</i><br><br>
<h4>Συνάρτηση insert_into:</h4>
<i>
Στις γραμμές 287-288 ξεκλειδώνουμε τον πίνακα δίοτι παρέμενε κλειδωμένος σε περίπτωση κάποιου exception.
</i><br><br>
<h4>Συνάρτηση select:</h4>
<i>
Στις γραμμές 365-398 γίνεται ο έλεγχος για την ύπαρξη ευρετηρίου για έναν συγκεκριμένο πίνακα. Εάν υπάρχει γίνονται κάποια ενδιάμεσα βήματα για να ξεχωρίσουμε αν είναι btree ή hash και έπειτα τα στέλνουμε σαν όρισμα στη συνάρτηση '_select_where' της κλάσης Table. Δεν χρησιμοποιούμε καθόλου την συνάρτηση '_select_where_with_btree' και όπως θα δείτε την έχουμε αφαιρέσει τελείως από την κλάση Table.
</i><br><br>
<h4>Συνάρτηση join:</h4>
<i>
Στις γραμμές 489-528 προστέθηκε ο κατάλληλος κώδικας για τον έλεγχο ύπαρξης ευρετηρίων και έαν ο πίνακας διαθέτει ευρετήριο να εφαρμόζεται επιτυχώς ο αλγόριθμος σύνδεσης Index Nested Loop Join (INLJ).
</i><br><br>
<h4>Συνάρτηση save_statistics:</h4>
<i>
Χρησιμοποιείται για την αποθήκευση των στατιστικών μας.
</i><br><br>
<h4>Συνάρτηση load_statistics:</h4>
<i>
Χρησιμοποιείται για την φόρτωση των στατιστικών μας.
</i><br><br>
<h4>Συνάρτηση calculate_tables_statistics:</h4>
<i>
Χρησιμοποιείται για τον υπολογισμό των στατιστικών μας.
</i><br><br>
<h4>Συνάρτηση print_statistics:</h4>
<i>
Χρησιμοποιείται για το τύπωμα των στατιστικών.
</i><br><br>
<h4>Συνάρτηση create_index:</h4>
<i>
Κάναμε τις απαραίτητες αλλαγές ώστε να υποστηρίζεται το ευρετήριο btree όσο και το hash. Γίνονται όλοι οι απαραίτητοι ελέγχοι ώστε να διασφαλίζεται η σωστή δημιουργία των ευρετηριών.<br>
Παραδοχή: Δεν μπορεί ένα πεδίο να έχει 2 ευρετηρία.
</i><br><br>
<h4>Συνάρτηση _construct_index:</h4>
<i>
Κάναμε τις απαραίτητες αλλαγές ώστε να υποστηρίζεται και η δημιουργία του ευρετηρίου hash.
</i><br><br>
<h4>Συνάρτηση _has_index:</h4>
<i>
Προσθέσαμε την δυνατότητα να γίνεται έλεγχος αν ένας πίνακας περιέχει ευρετήριο πάνω σε συγκεκριμένη στήλη.
</i><br><br>
<h3>Αρχείο table.py</h3>
<i>Σημείωση: Έχουμε διαγράψει την συνάρτηση 'select_where_with_btree' καθώς δεν μας ήταν χρήσιμη πλέον.</i><br>
<h4>Συνάρτηση __init__:</h4>
<i>
Κάναμε τις απαραίτητες προσθήκες ώστε ένας πίνακας να έχει στα χαρακτηριστικά του και τα unique πεδία.
</i><br>
<h4>Συνάρτηση _insert:</h4>
<i>
Προσθέσαμε τους απαραίτητους ελέγχους ώστε να γίνεται σωστή εισαγωγή εγγραφών.
</i><br>
<h4>Συνάρτηση _update_rows:</h4>
<i>
Στην γραμμή 164 καλείται η συνάρτηση 'find_rows_by_condition', η οποία μας επιστρέφει την θέση κάθε εγγραφής (προς ενημέρωση) του πίνακα. Η συνάρτηση 'find_rows_by_condition' θα επεξηγηθεί παρακάτω.
</i><br>
<h4>Συνάρτηση _delete_where:</h4>
<i>
Στην γραμμή 186 καλείται η συνάρτηση 'find_rows_by_condition', η οποία μας επιστρέφει την θέση κάθε εγγραφής (προς διαγραφή) του πίνακα.
</i><br>
<h4>Συνάρτηση _select_where:</h4>
<i>
Η συνάρτηση _select_where παίρνει 2 νέα ορίσματα, το 'btree_dic' και 'hash_dic'. Στην περίπτωση που ο πίνακας υποστηρίζει αναζήτηση μέσω ευρετηρίου, τα λεξικά θα περιέχουν  τα αντίστοιχα αντικείμενα (btree, hash). Όπως αναφέρθηκε παραπάνω, η συνάρτηση 'find_rows_by_condition' επιστρέφει την θέση κάθε εγγραφής που αναζητείται (αυτό μπορεί να γίνει είτε μέσω ευρετηρίου, είτε μέσω γραμμικής αναζήτησης και για αυτό στέλνουμε τα 2 λεξικά σαν όρισμα).
</i><br>
<h4>Συνάρτηση show:</h4>
<i>
Έχουμε προσθέσει την λέξη '#UNIQUE#' δίπλα από την ονομασία κάθε 'unique' πεδίου.
</i><br>
<h4>Συνάρτηση find_rows_by_condition:</h4>
<i>
Η κύρια λειτουργία της συνάρτησης είναι να διασχίζει το δοθέν λεξικό (πλάνο εκτέλεσης) σε βάθος. Αυτό επιτυγχάνεται καλώντας τον εαυτό της για κάθε left και right των operators and/or/between ή αν έχουμε operator not για την συνθήκη που ακολουθείται. Όταν φτάσει στο τέλος και εντοπίσει μια απλή συνθήκη, ψάχνει είτε μέσω ευρετηρίου, είτε μέσω γραμμικής αναζήτησης.
</i>

<h3>Αρχείο evaluate_query_plans.py</h3>
<i>Παραδοχές: 

1. Έχουμε μόνο ερωτήσεις ταυτότητας για την κοστολόγηση.
2. Τα 'select' προσμετρούνται πάντα στο κόστος, ασχέτως αν η επιλογή επιστρέφει όλες τις στήλες.
3. Αν έχουμε query όπως (SELECT * FROM E1 JOIN E2 ON θ1 AND θ2) δεν υποστηρίζεται η κοστολόγηση του, όταν όμως δημιουργηθούν ισοδύναμα πλάνα εκτέλεσης όπως (SELECT * FROM E1 JOIN E2 ON θ2 WHERE θ1(παραδοχή ότι η σύνδεση γίνεται στο θ2 και όχι στο θ1)) τότε υποστηρίζεται η κοστολόγηση του.</i><br>

<h4>Συνάρτηση evaluate_select_clause:</h4>
<i>
Είναι βοηθητική συνάρτηση για τον υπολογισμό του κόστους των ισοδύναμων πλάνων εκτέλεσης που δημιουργήσαμε. 
</i><br>
<h4>Συνάρτηση evaluate_query_plans:</h4>
<i>
Υπολογίζει το κάθε κόστος των queries που βρίσκονται στη λίστα 'queries' και μας επιστρέφει το query με το ελάχιστο κόστος.
</i>
<h3>Αρχείο query_plans.py</h3>
Οι κανόνες ΣΑ που υποστηρίζονται για την παραγωγή των ισοδύναμων πλάνων εκτέλεσης είναι οι εξής: 

1. Conjunctive selection operations can be deconstructed into a sequence of individual selections; cascade of σ.
     RA:σθ1∧θ2(E)
     SQL:SELECT * FROM E WHERE θ1 AND θ2;
         =
     RA:σθ1(σθ2(E))
     SQL:SELECT * FROM (SELECT * FROM E WHERE θ2) WHERE θ1; 
 
2. Selection operations are commutative:
     RA:σθ1(σθ2(E))
     SQL:SELECT * FROM (SELECT * FROM E WHERE θ2) WHERE θ1;
         =
     RA:σθ2(σθ1(E))
     SQL:SELECT * FROM (SELECT * FROM E WHERE θ1) WHERE θ2;
 
3. Only the final operations in a sequence of projection operations is needed, the others can be omitted; cascade of Π.
 
     RA:ΠL1(ΠL2(. . .(ΠLn(E)). . .))
     SQL:SELECT L1 FROM (SELECT L2 FROM (...SELECT Ln FROM E ...)) 
         =
     RA:ΠL1(E)
     SQL:SELECT L1 FROM E;
 
4. Selections can be combined with Cartesian products and theta joins:
 
     RA:σθ1(E1 |><|θ2 E2)
     SQL:SELECT * FROM E1 JOIN E2 ON θ2 WHERE θ1;
         =
     RA:E1 |><|θ1∧θ2 E2
     SQL:SELECT * FROM E1 JOIN E2 ON θ1 AND θ2;
 
5. Theta join operations are commutative:
 
     RA:E1 |><|θ E2
     SQL:SELECT * FROM E1 JOIN E2 ON θ;
         =
     RA:E2 |><|θ E1
     SQL:SELECT * FROM E2 JOIN E1 ON θ;

<h4>Συνάρτηση get_final_from:</h4>
<i>
Χρησιμοποιείται για τον τρίτο κανόνα της ΣΑ.
</i><br>
<h4>Συνάρτηση count_selects:</h4>
<i>
Χρησιμοποιείται για την εύρεση πλήθους των 'select' clause, που βρίσκονται μέσα στο πλάνο εκτέλεσης που μας επέστρεψε η συνάρτηση 'interpret' (του mdb.py).
</i><br>
<h4>Συνάρτηση check_query:</h4>
<i>
Η συνάρτηση 'check_query' εκτελείται ώστε να ελέγξει αν εφαρμόζονται οι κανόνες ΣΑ που υποστηρίζονται παραπάνω.
</i><br>
<h4>Συνάρτηση multiple_query_plans:</h4>
<i>
Εάν το query υποστηρίζει την παραγωγή ισοδύναμων πλάνων εκτέλεσης (βάσει των παραπάνω κανόνων ΣΑ), δημιουργεί ισοδύναμα πλάνα εκτέλεσης για το δοθέν query. Επιστρέφει μια λίστα με τα ισοδύναμα πλάνα εκτέλεσης και μια λογική τιμή όπου καθορίζει έαν πρέπει να εκτελεστεί η συνάρτηση 'evaluate_query_plans' (του evaluate_query_plans.py) μέσα στην κύρια συνάρτηση (του mdb.py). Αν δεν υποστηρίζεται από τους πιο πάνω κανόνες ΣΑ, επιστρέφει μια λίστα με το αρχικό query και μια λογική τιμή όπου δεν επιτρέπει στην συνάρτηση 'evaluate_query_plans' να εκτελεστεί.
</i><br>

<h3>Αρχείο extendible_hasing.py</h3>
Η κλάση ExtendibleHashing υλοποιεί τον επεκτάσιμο κατακερματισμό. Επιλέξαμε ο κατακερματισμός να γίνεται βάσει του LSB (Least Significant Bit).<br>
<h4>Συνάρτηση __init__:</h4>
<i>
Παίρνει ως πρώτο όρισμα τον πλήθος bit που θα χρησιμοποιηθούν αρχικά για την κατανομή του κάθε κλειδιού στο αντίστοιχο bucket και αποθηκεύεται στο μεταβλητή bits. Σαν δεύτερο όρισμα παίρνει τον μέγιστο αριθμό εγγραφών που μπορεί να έχει ο κάθε bucket και τον αποθηκεύει μέσα στην μεταβλητή bucket_size. Επίσης, βάσει του πλήθος bit που θα δοθούν, δημιουργούνται και οι αντίστοιχοι bucket.
</i><br>
<h4>Συνάρτηση _hash:</h4>
<i>
Αντιστοιχεί στην συνάρτηση κατακερματισμού.
</i><br>
<h4>Συνάρτηση _add:</h4>
<i>
Προσθέτει στον κατάλληλο bucket τον συνδυασμό κλειδιού (key) και τιμής (value).
</i><br>
<h4>Συνάρτηση _remove:</h4>
<i>
Αφαιρεί απο συγκεκριμένο bucket τον συνδυασμό κλειδιού (key), τιμής (value) και επιστρέφει True αν ήταν επιτυχής, αλλιώς επιστρέφει False.
</i><br>
<h4>Συνάρτηση _get:</h4>
<i>
Επιστρέφει την τιμή (value) ενός συγκεκριμένου δοθέντος κλειδιού. Αν δεν βρεθεί επιστρέφει None.
</i><br>
<h4>Συνάρτηση _split:</h4>
<i>
Η συνάρτηση '_split' καλείται όταν ο bucket που θέλουμε να γίνει εισάγωγη ενός κλειδιού (key), τιμής (value) είναι γεμάτος και επομένως πρέπει να δημιουργηθούν νέοι bucket και να γίνει διαχωρισμός των εγγραφών του.
</i><br>
<h4>Συνάρτηση _print:</h4>
<i>
Η συνάρτηση '_print' καλείται για το τύπωμα του πίνακα κατακερματισμού.
</i>